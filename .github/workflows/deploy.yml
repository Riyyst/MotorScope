/**
 * MotorScope Backend â€” Cloudflare Worker (CORS SAFE)
 *
 * FRONTEND_ORIGIN can be provided as CFG_FRONTEND_ORIGIN (preferred) or FRONTEND_ORIGIN.
 * Set it to: https://riystt.github.io
 */

const enc = new TextEncoder();
const dec = new TextDecoder();

/* ---------------- CORS helpers ---------------- */
function getAllowedOrigin(env) {
  return env.CFG_FRONTEND_ORIGIN || env.FRONTEND_ORIGIN || "*";
}
function corsHeaders(origin) {
  return {
    "Access-Control-Allow-Origin": origin,
    "Vary": "Origin",
    "Access-Control-Allow-Methods": "GET,POST,OPTIONS",
    "Access-Control-Allow-Headers": "Content-Type, Authorization, X-Requested-With, x-client-token",
    "Access-Control-Max-Age": "86400",
  };
}
function withCORS(resp, origin) {
  const out = new Response(resp.body, resp);
  for (const [k, v] of Object.entries(corsHeaders(origin))) out.headers.set(k, v);
  return out;
}
function json(data, { status = 200, headers = {} } = {}) {
  return new Response(JSON.stringify(data), {
    status,
    headers: { "content-type": "application/json; charset=utf-8", ...headers },
  });
}

/* ---------------- utils ---------------- */
function cleanVRM(s = "") {
  return s.toUpperCase().replace(/[^A-Z0-9]/g, "");
}
function q(url, name) {
  return new URL(url).searchParams.get(name);
}

/* ------------- anti-spam token (HMAC) ------------- */
function b64urlEncode(arrBuf) {
  let s = btoa(String.fromCharCode(...new Uint8Array(arrBuf)));
  return s.replace(/\+/g, "-").replace(/\//g, "_").replace(/=+$/g, "");
}
function b64urlDecodeToUint8(str) {
  str = str.replace(/-/g, "+").replace(/_/g, "/");
  const pad = str.length % 4 ? "=".repeat(4 - (str.length % 4)) : "";
  const bin = atob(str + pad);
  const buf = new Uint8Array(bin.length);
  for (let i = 0; i < bin.length; i++) buf[i] = bin.charCodeAt(i);
  return buf;
}
function jsonToB64url(obj) { return b64urlEncode(enc.encode(JSON.stringify(obj))); }
function b64urlToJson(str) { return JSON.parse(dec.decode(b64urlDecodeToUint8(str))); }

async function hmacSign(data, secret) {
  const key = await crypto.subtle.importKey("raw", enc.encode(secret), { name: "HMAC", hash: "SHA-256" }, false, ["sign"]);
  const sig = await crypto.subtle.sign("HMAC", key, enc.encode(data));
  return b64urlEncode(sig);
}
async function createAntiSpamToken(vrm, env) {
  const now = Date.now();
  const payload = { vrm, iat: now, exp: now + 120_000 };
  const body = jsonToB64url(payload);
  const sig = await hmacSign(body, env.ANTISPAM_SECRET);
  return `${body}.${sig}`;
}

/* ------------- DVLA VES ------------- */
async function getVES(vrm, env) {
  const url = "https://driver-vehicle-licensing.api.gov.uk/vehicle-enquiry/v1/vehicles";
  const r = await fetch(url, {
    method: "POST",
    headers: { "content-type": "application/json", "x-api-key": env.DVLA_VES_API_KEY },
    body: JSON.stringify({ registrationNumber: vrm }),
  });
  if (!r.ok) throw new Error(`DVLA VES ${r.status}: ${await r.text().catch(()=>'')}`);
  return r.json();
}

/* ------------- DVSA MOT ------------- */
let _motTokenCache = { token: null, exp: 0 };
async function getDvsaToken(env) {
  const now = Date.now();
  if (_motTokenCache.token && _motTokenCache.exp > now + 10_000) return _motTokenCache.token;

  const body = new URLSearchParams({
    grant_type: "client_credentials",
    client_id: env.DVSA_MOT_CLIENT_ID,
    client_secret: env.DVSA_MOT_CLIENT_SECRET,
    scope: env.DVSA_MOT_SCOPE || "https://tapi.dvsa.gov.uk/.default",
  });
  const r = await fetch(env.DVSA_MOT_TOKEN_URL, {
    method: "POST",
    headers: { "content-type": "application/x-www-form-urlencoded" },
    body,
  });
  if (!r.ok) throw new Error(`DVSA token ${r.status}: ${await r.text().catch(()=>'')}`);
  const j = await r.json();
  _motTokenCache = { token: j.access_token, exp: now + (Number(j.expires_in)||3600) * 1000 };
  return j.access_token;
}
async function getMOT(vrm, env) {
  const base = env.DVSA_MOT_API_BASE || "https://beta.check-mot.service.gov.uk";
  const url = `${base}/trade/vehicles/mot-tests?registration=${encodeURIComponent(vrm)}`;
  const bearer = await getDvsaToken(env);
  const r = await fetch(url, {
    headers: { Authorization: `Bearer ${bearer}`, "x-api-key": env.DVSA_MOT_API_KEY, accept: "application/json" },
  });
  if (!r.ok) throw new Error(`DVSA MOT ${r.status}: ${await r.text().catch(()=>'')}`);
  return r.json();
}

/* ---------------- Worker ---------------- */
export default {
  async fetch(request, env, ctx) {
    const origin = getAllowedOrigin(env);

    // Handle preflight first
    if (request.method === "OPTIONS") {
      return withCORS(new Response(null, { status: 204 }), origin);
    }

    try {
      const url = new URL(request.url);

      if (request.method === "GET" && (url.pathname === "/" || url.pathname === "/__healthz")) {
        return withCORS(json({ ok: true, ts: Date.now() }), origin);
      }

      if (url.pathname === "/api/antispam" && request.method === "POST") {
        const body = await request.json().catch(() => ({}));
        const vrm = cleanVRM(body.vrm || "");
        if (!vrm) return withCORS(json({ error: "Missing vrm" }, { status: 400 }), origin);
        const token = await createAntiSpamToken(vrm, env);
        return withCORS(json({ token }), origin);
      }

      if (url.pathname === "/api/ves" && request.method === "GET") {
        const vrm = cleanVRM(q(request.url, "vrm") || "");
        if (!vrm) return withCORS(json({ error: "Missing vrm" }, { status: 400 }), origin);
        const data = await getVES(vrm, env);
        return withCORS(json(data), origin);
      }

      if (url.pathname === "/api/mot/tests" && request.method === "GET") {
        const vrm = cleanVRM(q(request.url, "vrm") || "");
        if (!vrm) return withCORS(json({ error: "Missing vrm" }, { status: 400 }), origin);
        const data = await getMOT(vrm, env);
        return withCORS(json(data), origin);
      }

      return withCORS(json({ error: "Not found" }, { status: 404 }), origin);
    } catch (err) {
      return withCORS(json({ error: "Server error", detail: String(err?.message || err) }, { status: 500 }), getAllowedOrigin(env));
    }
  },
};
